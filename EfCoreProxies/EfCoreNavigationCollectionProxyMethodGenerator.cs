using System;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeBasics.EfCoreProxies
{
  [Generator]
  public class EfCoreNavigationCollectionProxyMethodGenerator : ISourceGenerator
  {
    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
      try
      {

        // uncomment to debug the actual build of the target project
        //Debugger.Launch();
        var compilation = context.Compilation;

        // compilation.SyntaxTrees = all files in the target project
        foreach (var syntaxTree in compilation.SyntaxTrees)
        {
          // syntax = all keywords, definitions, etc - like AST
          // semantics = what members are implemented, what interfaces inherited, etc.

          var semanticModel = compilation.GetSemanticModel(syntaxTree);

          var types = syntaxTree
                       .GetRoot()
                       .DescendantNodesAndSelf()
                       .OfType<ClassDeclarationSyntax>()
                       .Select(c => semanticModel.GetDeclaredSymbol(c))
                       .OfType<ITypeSymbol>()
                       .ToArray();

          var tuples = types
                      .Select(t => (
                         Type: t,
                         CollectionProps: t.GetMembers()
                                           .OfType<IPropertySymbol>()
                                           .Where(m => m.IsVirtual
                                                    && m.Type.Name == "ICollection")
                                           .ToArray()))
                      .Where(tup => tup.CollectionProps.Any())
                      .ToArray();

          foreach (var typeSymbol in tuples)
          {
            var source = generatePartialClass(typeSymbol.Type, typeSymbol.CollectionProps);
            context.AddSource($"{typeSymbol.Type.Name}.NavigationCollectionProxy.cs", source);
          }
        }
      }
      catch (Exception e)
      {
        Debug.WriteLine("Code generation failed: " + e);
      }
    }

    private string generatePartialClass(ITypeSymbol typeSymbol, IPropertySymbol[] typeSymbolCollectionProps)
    {
      return $@"
// <auto-generated>
using System.ComponentModel;
using System.Linq;
using Microsoft.EntityFrameworkCore;

namespace {typeSymbol.ContainingNamespace}
{{
  partial class {typeSymbol.Name}
  {{
    public {typeSymbol.Name}(DbContext entities) : this()
    {{
      this.Entities = entities;
    }}

    private DbContext Entities {{ get; set; }}

    {generateMethods(typeSymbol, typeSymbolCollectionProps)}
  }}
}}".Trim();
    }

    private static string generateMethods(ITypeSymbol typeSymbol, IPropertySymbol[] propertySymbols)
    {
      var sb = new StringBuilder();

      foreach (var propertySymbol in propertySymbols)
      {
        if (propertySymbol.Type is not INamedTypeSymbol { TypeArguments: { Length: 1 } } symbol)
        {
          continue;
        }

        var propertyName = propertySymbol.Name;
        var nestedPropertyType = symbol.TypeArguments[0];

        sb.AppendLine($@"
    /// <summary>
    /// Gets a IQueryable for the <see cref=""{typeSymbol.Name}.{propertyName}""/> collection.
    /// Use this to avoid eager-load of all related entities.
    /// </summary>
    public IQueryable<{nestedPropertyType}> {propertyName}Query()
    {{
      if (Entities is null)
      {{
        return {propertyName}.AsQueryable();
      }}

      var entityEntry = Entities.Entry(this);
      var collectionEntry = entityEntry.Collection(e => e.{propertyName});
      var query = collectionEntry.Query();

      return query;
    }}".Trim(Environment.NewLine.ToArray())).AppendLine();
      }

      return sb.ToString().Trim();
    }
  }
}