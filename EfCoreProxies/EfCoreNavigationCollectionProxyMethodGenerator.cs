using System;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeBasics.EfCoreProxies
{
  [Generator]
  public class EfCoreNavigationCollectionProxyMethodGenerator : ISourceGenerator
  {
    public void Initialize(GeneratorInitializationContext context)
    {
      // TODO: check if the assembly contains a class based on DbContext
    }

    public void Execute(GeneratorExecutionContext context)
    {
      try
      {
        // uncomment to debug the actual build of the target project
        //Debugger.Launch();

        var compilation = context.Compilation;

        var filesAdded = false;

        // compilation.SyntaxTrees = all files in the target project
        foreach (var syntaxTree in compilation.SyntaxTrees)
        {
          // syntax = all keywords, definitions, etc - like AST
          // semantics = what members are implemented, what interfaces inherited, etc.

          var semanticModel = compilation.GetSemanticModel(syntaxTree);

          var types = syntaxTree
                       .GetRoot()
                       .DescendantNodesAndSelf()
                       .OfType<ClassDeclarationSyntax>()
                       .Select(c => semanticModel.GetDeclaredSymbol(c))
                       .OfType<ITypeSymbol>()
                       .ToArray();

          // TODO: check somehow if the class is partial -> warn if not

          var tuples = types
                      .Select(t => (
                         Type: t,
                         CollectionProps: t.GetMembers()
                                           .OfType<IPropertySymbol>()
                                           .Where(m => m.IsVirtual
                                                    && m.Type.Name == "ICollection")
                                           .ToArray()))
                      .Where(tup => tup.CollectionProps.Any())
                      .ToArray();

          foreach (var typeSymbol in tuples)
          {
            filesAdded = true;

            var source = generatePartialClass(typeSymbol.Type, typeSymbol.CollectionProps);
            context.AddSource($"{typeSymbol.Type.Name}.NavigationCollectionProxy.cs", source);
          }
        }

        if (filesAdded)
        {
          var attributeSource = GenerateAttributeHeader() + GenerateAttribute();
          context.AddSource("EfCoreNavigationCollectionProxyGeneratedAttribute.cs", attributeSource);
        }
      }
      catch (Exception e)
      {
        Debug.WriteLine("Code generation failed: " + e);
      }
    }

    public static string GenerateAttributeHeader()
    {
      return @"
// <auto-generated>
using System;

".TrimStart();
    }

    public static string GenerateAttribute()
    {
      return @"
namespace CodeBasics.EfCoreProxies
{
  /// <summary>
  /// Attribute to mark entities that are extended with special query methods.
  /// </summary>
  [AttributeUsage(AttributeTargets.Class, Inherited = true, AllowMultiple = false)]
  public sealed class EfCoreNavigationCollectionProxyGeneratedAttribute : Attribute
  {
  }
}".Trim();
    }

    private string generatePartialClass(ITypeSymbol typeSymbol, IPropertySymbol[] typeSymbolCollectionProps)
    {
      return $@"
// <auto-generated>
using System.ComponentModel;
using System.Linq;
using Microsoft.EntityFrameworkCore;

namespace {typeSymbol.ContainingNamespace}
{{
  [CodeBasics.EfCoreProxies.EfCoreNavigationCollectionProxyGenerated]
  partial class {typeSymbol.Name}
  {{
    /// <summary>
    /// Constructor for EntityFramework. Don't use it! You have been warned.
    /// </summary>
    [System.Obsolete(""For internal use only."")]
    public {typeSymbol.Name}(DbContext context) : this()
    {{
      this.Context = context;
    }}

    /// <summary>
    /// Private property to support entity framework to set the context once the entity gets attached.
    /// </summary>
    private DbContext Context {{ get; set; }}

    {generateMethods(typeSymbol, typeSymbolCollectionProps)}
  }}
}}".Trim();
    }

    private static string generateMethods(ITypeSymbol typeSymbol, IPropertySymbol[] propertySymbols)
    {
      var sb = new StringBuilder();

      foreach (var propertySymbol in propertySymbols)
      {
        if (propertySymbol.Type is not INamedTypeSymbol { TypeArguments: { Length: 1 } } symbol)
        {
          continue;
        }

        var propertyName = propertySymbol.Name;
        var nestedPropertyType = symbol.TypeArguments[0];

        sb.AppendLine($@"
    /// <summary>
    /// Gets a IQueryable for the <see cref=""{typeSymbol.Name}.{propertyName}""/> collection.
    /// Use this to avoid eager-load of all related entities.
    /// </summary>
    public IQueryable<{nestedPropertyType}> {propertyName}Query()
    {{
      if (Context is null)
      {{
        return {propertyName}.AsQueryable();
      }}

      var entityEntry = Context.Entry(this);
      var collectionEntry = entityEntry.Collection(e => e.{propertyName});
      var query = collectionEntry.Query();

      return query;
    }}".Trim(Environment.NewLine.ToArray())).AppendLine();
      }

      return sb.ToString().Trim();
    }
  }
}